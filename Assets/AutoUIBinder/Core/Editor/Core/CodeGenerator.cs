using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;
using AutoUIBinder;

namespace AutoUIBinder.Editor
{
    /// <summary>
    /// 代码生成器 - 负责UI组件属性代码生成
    /// </summary>
    public class CodeGenerator
    {
        
        /// <summary>
        /// 生成UI代码
        /// </summary>
        public void GenerateUICode(AutoUIBinderBase target)
        {
            string className = target.GetType().Name;
            Debug.Log($"[AutoUIBinder] 为 {className} 生成UI代码，包含 {target.ComponentRefs.Count} 个组件");
            
            try
            {
                // 1. 确保目标类是partial类
                EnsurePartialClass(target);
                
                // 2. 获取生成路径配置
                var globalConfig = Resources.Load<UIPathConfig>("GlobalConfig");
                if (globalConfig == null)
                {
                    Debug.LogError("[AutoUIBinder] 未找到GlobalConfig配置文件");
                    return;
                }
                
                // 3. 创建生成目录
                string genFolderPath = System.IO.Path.Combine(globalConfig.Paths, "Gen");
                string classGenFolderPath = System.IO.Path.Combine(genFolderPath, className);
                
                if (!System.IO.Directory.Exists(classGenFolderPath))
                {
                    System.IO.Directory.CreateDirectory(classGenFolderPath);
                }
                
                // 4. 生成代码文件
                string genFilePath = System.IO.Path.Combine(classGenFolderPath, $"{className}Gen.cs");
                string absoluteFilePath = System.IO.Path.GetFullPath(genFilePath);
                
                GenerateUICodeFile(target, absoluteFilePath);
                
                // 5. 刷新资源
                AssetDatabase.Refresh();
                
                Debug.Log($"[AutoUIBinder] UI代码生成完成: {genFilePath}");
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"[AutoUIBinder] UI代码生成失败: {ex.Message}\n{ex.StackTrace}");
                throw;
            }
        }
        
        
        
        
        
        
        
        
        /// <summary>
        /// 确保目标类是partial类
        /// </summary>
        private void EnsurePartialClass(AutoUIBinderBase target)
        {
            var script = MonoScript.FromMonoBehaviour(target as MonoBehaviour);
            var scriptPath = AssetDatabase.GetAssetPath(script);
            string content = File.ReadAllText(scriptPath);
            string className = target.GetType().Name;
            
            // 检查是否已经是partial类
            if (!content.Contains($"partial class {className}"))
            {
                // 将class修改为partial class
                content = content.Replace($"class {className}", $"partial class {className}");
                File.WriteAllText(scriptPath, content);
                AssetDatabase.Refresh();
                Debug.Log($"[AutoUIBinder] 已将 {className} 修改为 partial 类");
            }
        }
        
        /// <summary>
        /// 生成UI代码文件
        /// </summary>
        private void GenerateUICodeFile(AutoUIBinderBase target, string filePath)
        {
            string className = target.GetType().Name;
            var script = MonoScript.FromMonoBehaviour(target as MonoBehaviour);
            string scriptPath = AssetDatabase.GetAssetPath(script);
            
            var codeBuilder = new StringBuilder();
            
            // 生成文件头注释
            codeBuilder.AppendLine("//------------------------------------------------------------------------------");
            codeBuilder.AppendLine("// <auto-generated>");
            codeBuilder.AppendLine("//     此代码由工具自动生成。");
            codeBuilder.AppendLine($"//     运行时版本:{Application.unityVersion}");
            codeBuilder.AppendLine($"//     生成时间: {System.DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            codeBuilder.AppendLine($"//     组件数量: {target.ComponentRefs.Count}");
            codeBuilder.AppendLine($"//     预制体路径: ");
            codeBuilder.AppendLine($"//     脚本路径: {scriptPath}");
            codeBuilder.AppendLine($"//     生成路径: {filePath}");
            codeBuilder.AppendLine("//");
            codeBuilder.AppendLine("//     对此文件的更改可能会导致不正确的行为，并且如果");
            codeBuilder.AppendLine("//     重新生成代码，这些更改将会丢失。");
            codeBuilder.AppendLine("// </auto-generated>");
            codeBuilder.AppendLine("//------------------------------------------------------------------------------");
            codeBuilder.AppendLine();
            
            // 添加using语句
            var usingStatements = GetRequiredUsingStatements(target);
            foreach (var usingStatement in usingStatements)
            {
                codeBuilder.AppendLine(usingStatement);
            }
            codeBuilder.AppendLine();
            
            // 生成partial类定义
            codeBuilder.AppendLine($"public partial class {className}");
            codeBuilder.AppendLine("{");
            
            // 为每个组件生成属性
            foreach (var kvp in target.ComponentRefs)
            {
                if (kvp.Value != null)
                {
                    string componentTypeName = kvp.Value.GetType().Name;
                    string propertyName = kvp.Key;
                    codeBuilder.AppendLine($"    /// <summary>");
                    codeBuilder.AppendLine($"    /// 获取{componentTypeName}组件: {propertyName}");
                    codeBuilder.AppendLine($"    /// </summary>");
                    codeBuilder.AppendLine($"    public {componentTypeName} {propertyName}");
                    codeBuilder.AppendLine($"    {{");
                    codeBuilder.AppendLine($"        get");
                    codeBuilder.AppendLine($"        {{");
                    codeBuilder.AppendLine($"            return this.GetComponentRef<{componentTypeName}>(\"{kvp.Key}\");");
                    codeBuilder.AppendLine($"        }}");
                    codeBuilder.AppendLine($"    }}");
                    codeBuilder.AppendLine();
                }
            }
            
            codeBuilder.AppendLine("}");
            
            // 写入文件
            File.WriteAllText(filePath, codeBuilder.ToString(), System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// 获取生成代码所需的using语句
        /// </summary>
        private List<string> GetRequiredUsingStatements(AutoUIBinderBase target)
        {
            var usingStatements = new HashSet<string>();
            
            // 基础的using语句
            usingStatements.Add("using UnityEngine;");
            usingStatements.Add("using UnityEngine.UI;");
            
            // 检查所有组件类型，添加对应的using语句
            foreach (var kvp in target.ComponentRefs)
            {
                if (kvp.Value != null)
                {
                    var componentType = kvp.Value.GetType();
                    var namespaceName = componentType.Namespace;
                    
                    // 根据命名空间添加对应的using语句
                    if (!string.IsNullOrEmpty(namespaceName))
                    {
                        switch (namespaceName)
                        {
                            case "TMPro":
                                usingStatements.Add("using TMPro;");
                                break;
                            case "UnityEngine.Video":
                                usingStatements.Add("using UnityEngine.Video;");
                                break;
                            case "UnityEngine.Playables":
                                usingStatements.Add("using UnityEngine.Playables;");
                                break;
                            case "UnityEngine.Timeline":
                                usingStatements.Add("using UnityEngine.Timeline;");
                                break;
                            // 可以根据需要添加更多命名空间
                        }
                    }
                }
            }
            
            // 转换为排序的列表
            var result = usingStatements.ToList();
            result.Sort();
            return result;
        }

        private string GetFriendlyTypeName(System.Type type)
        {
            using (var provider = new Microsoft.CSharp.CSharpCodeProvider())
            {
                var typeReference = new System.CodeDom.CodeTypeReference(type);
                string typeName = provider.GetTypeOutput(typeReference);
                
                int lastDot = typeName.LastIndexOf('.');
                if (lastDot >= 0)
                {
                    typeName = typeName.Substring(lastDot + 1);
                }
                
                return typeName;
            }
        }
    }
}